// Copyright 2020 Vedran Vuk. All rights reserved.
// Use of this source code is governed by a MIT
// license that can be found in the LICENSE file.

package ttl

import (
	"sync"
	"time"
)

// ItemID is an unique item id generated by TTL when adding a new item.
// It is incremented sequentially, no entropy.
type ItemID uint64

// OnItemTimeout is a prototype of a callback function to receive an
// item timeout notification where id will be the id of the item that timed
// out and value being the value of that item.
type OnItemTimeout func(id ItemID, value interface{})

// InvalidItemID is an invalid ItemID.
const InvalidItemID ItemID = 0

// Item is an item in TTL list.
type Item struct {
	id        ItemID
	next      *Item
	prev      *Item
	timeoutAt time.Time

	Value interface{}
}

// TTL is a timeout queue that times out added items with a given Time To Live.
// TTL uses a timer to trim outdated items. Precision is low, always slightly
// late, a smidgen after item's real timeout, each time.
type TTL struct {
	mu        sync.Mutex
	head      *Item
	tail      *Item
	ids       map[ItemID]*Item
	nextid    ItemID
	timer     *time.Timer
	nexttick  time.Time
	resetchan chan struct{}
	running   bool
	cb        OnItemTimeout
}

// New returns a new TTL instance.
// Optional callback function cb is called when an item times out.
func New(cb OnItemTimeout) *TTL {
	p := &TTL{
		ids:       make(map[ItemID]*Item),
		cb:        cb,
		timer:     time.NewTimer(0),
		mu:        sync.Mutex{},
		resetchan: make(chan struct{}),
	}
	return p
}

// timerFunc is the timer goroutine that polls the timer for events.
// It contends for TTL's public interface mutex.
func (ttl *TTL) timerFunc() {

	ttl.mu.Lock()
	ttl.running = true
	ttl.mu.Unlock()

	var tick time.Time
	for {

		select {
		case <-ttl.resetchan:
			break
		case tick = <-ttl.timer.C:
			break
		}

		ttl.mu.Lock()

		// Ignore delayed ticks of reset timer.
		if tick.Before(ttl.nexttick) {
			ttl.mu.Unlock()
			continue
		}
		ttl.nexttick = tick

		// Channel needs not be exhausted,
		// fires at least once even when empty.
		ttl.timer.Stop()

		ttl.trim()

		// Exit thread if queue is empty.
		if ttl.head == nil {
			ttl.running = false
			ttl.mu.Unlock()
			break
		}

		// Otherwise reset timer and note fire time.
		ttl.nexttick = ttl.head.timeoutAt
		ttl.timer.Reset(time.Until(ttl.head.timeoutAt))

		ttl.mu.Unlock()
	}
}

// Add adds specified value to TTL with the specified timeout. Returns an id
// under which the item was stored.
func (ttl *TTL) Add(value interface{}, timeout time.Duration) (id ItemID) {
	ttl.mu.Lock()

	ttl.nextid++
	id = ttl.nextid

	p := &Item{
		id:        id,
		timeoutAt: time.Now().Add(timeout),
		Value:     value,
	}

	ttl.ids[id] = p
	ttl.add(p)

	if !ttl.running {
		go func() {
			go ttl.timerFunc()
			ttl.resetchan <- struct{}{}
		}()
	}
	ttl.mu.Unlock()

	return
}

// Reset resets the timeout for an item with the specified id. Returns truth
// if the item with the specified id was found and was reset.
func (ttl *TTL) Reset(id ItemID, timeout time.Duration) (ok bool) {

	ttl.mu.Lock()

	item, exists := ttl.ids[id]
	if !exists {
		ttl.mu.Unlock()
		return false
	}

	if _, removed := ttl.remove(id); !removed {
		panic("mapped item not in list")
	}

	item.timeoutAt = time.Now().Add(timeout)
	ttl.add(item)
	ttl.ids[item.id] = item

	if !ttl.running {
		go func() {
			go ttl.timerFunc()
			ttl.resetchan <- struct{}{}
		}()
	}
	ttl.mu.Unlock()

	return true
}

// Remove removes an item with the specified id from the TTL if it exists and
// returns it with the truth if it was found.
func (ttl *TTL) Remove(id ItemID) (item *Item, exists bool) {

	ttl.mu.Lock()

	item, exists = ttl.remove(id)
	if !exists {
		ttl.mu.Unlock()
		return
	}

	if !ttl.running {
		go func() {
			go ttl.timerFunc()
			ttl.resetchan <- struct{}{}
		}()
	}
	ttl.mu.Unlock()

	return
}

// addhead adds the item by searching from the the head.
func (ttl *TTL) addhead(item *Item) {
	var last *Item
	for curr := ttl.head; curr != nil; curr = curr.next {
		if curr.timeoutAt.After(item.timeoutAt) {
			if last == nil {
				ttl.head = item
			} else {
				last.next = item
				if last.next != nil {
					last.next.prev = item
				}
				item.prev = last
				item.next = last.next
			}
			item.next = curr
			curr.prev = item
			return
		}
		last = curr
	}
	if last == nil {
		ttl.head = item
		ttl.tail = item
	} else {
		last.next = item
		item.prev = last
		if last == ttl.tail {
			ttl.tail = item
		}
	}
}

// addtail adds the item by searching from the the tail.
func (ttl *TTL) addtail(item *Item) {
	var last *Item
	for curr := ttl.tail; curr != nil; curr = curr.prev {
		if curr.timeoutAt.Before(item.timeoutAt) {
			if last == nil {
				ttl.tail = item
			} else {
				item.prev = curr
				item.next = last
				last.prev = item
			}
			item.prev = curr
			curr.next = item
			return
		}
		last = curr
	}
	if last == nil {
		ttl.head = item
		ttl.tail = item
	} else {
		last.prev = item
		item.next = last
		if ttl.head == last {
			ttl.head = item
		}
	}
}

// add inserts the item in the list so that the list is sorted by
// timeout timestamp sorted by soonest. Same timestamps are impossibru.
func (ttl *TTL) add(item *Item) {
	ttl.addtail(item)
}

// remove removes an item with the specified id from the list.
func (ttl *TTL) remove(id ItemID) (item *Item, exists bool) {

	item, exists = ttl.ids[id]
	if !exists {
		return nil, false
	}

	delete(ttl.ids, item.id)

	if item.prev != nil {
		item.prev.next = item.next
	}
	if item.next != nil {
		item.next.prev = item.prev
	}
	if item == ttl.head {
		ttl.head = item.next
	}
	if item == ttl.tail {
		ttl.tail = item.prev
	}
	item.prev = nil
	item.next = nil

	return
}

// trim removes all items whose timeout is before now.
func (ttl *TTL) trim() (count int) {
	for curr, now := ttl.head, time.Now(); curr != nil; curr = ttl.head {
		if curr.timeoutAt.After(now) {
			break
		}
		item, removed := ttl.remove(curr.id)
		if !removed {
			break
		}
		count++
		if ttl.cb != nil {
			ttl.cb(curr.id, item.Value)
		}
	}
	return
}
